<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Docker Container Monitor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-card: #334155;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --accent: #3b82f6;
            --accent-hover: #2563eb;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --border: #475569;
            --terminal-bg: #000000;
            --terminal-green: #00ff00;
            --terminal-red: #ff0000;
            --terminal-yellow: #ffff00;
            --terminal-cyan: #00ffff;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            height: 100vh;
            overflow: hidden;
        }

        .app-container {
            display: flex;
            height: 100vh;
        }

        /* Sidebar Styles */
        .sidebar {
            width: 280px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
        }

        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
        }

        .sidebar-title {
            font-size: 18px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .containers-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px 0;
        }

        .container-item {
            padding: 12px 20px;
            cursor: pointer;
            border-left: 3px solid transparent;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .container-item:hover {
            background: var(--bg-card);
        }

        .container-item.active {
            background: var(--bg-card);
            border-left-color: var(--accent);
        }

        .container-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .status-running {
            background: var(--success);
        }

        .status-stopped {
            background: var(--danger);
        }

        .status-exited {
            background: var(--warning);
        }

        .status-unknown {
            background: var(--text-secondary);
        }

        .container-name {
            flex: 1;
            font-weight: 500;
        }

        /* Main Content Styles */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Stats Header */
        .stats-header {
            background: var(--bg-secondary);
            padding: 15px 20px;
            border-bottom: 1px solid var(--border);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .stat-label {
            font-size: 12px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-value {
            font-size: 16px;
            font-weight: 600;
        }

        /* Terminal Styles */
        .terminal-container {
            flex: 1;
            background: var(--terminal-bg);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .terminal-header {
            background: #2d3748;
            padding: 10px 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .terminal-title {
            font-weight: 600;
            color: var(--terminal-cyan);
        }

        .terminal-controls {
            display: flex;
            gap: 10px;
        }

        .terminal-controls button {
            background: var(--bg-card);
            border: none;
            color: var(--text-primary);
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .terminal-controls button:hover {
            background: var(--accent);
        }

        .terminal-controls button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .terminal-controls button:disabled:hover {
            background: var(--bg-card);
        }

        .terminal-content {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.4;
        }

        .log-line {
            margin-bottom: 2px;
            word-break: break-all;
            display: flex;
            gap: 10px;
        }

        .log-time {
            color: var(--terminal-cyan);
            flex-shrink: 0;
            min-width: 180px;
        }

        .log-message {
            flex: 1;
        }

        .log-error {
            color: var(--terminal-red);
        }

        .log-warning {
            color: var(--terminal-yellow);
        }

        .log-info {
            color: var(--terminal-green);
        }

        .log-debug {
            color: var(--terminal-cyan);
        }

        .empty-terminal {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--text-secondary);
            font-style: italic;
        }

        /* Loading States */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            color: var(--text-secondary);
        }

        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Responsive */
        @media (max-width: 768px) {
            .sidebar {
                width: 200px;
            }
            
            .stats-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <div class="sidebar">
            <div class="sidebar-header">
                <h2 class="sidebar-title">
                    <span>üê≥</span>
                    Docker Monitor
                </h2>
            </div>
            <div class="containers-list" id="containersList">
                <div class="loading">
                    <div class="spinner"></div>
                    Loading containers...
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <!-- Stats Header -->
            <div class="stats-header" id="statsHeader" style="display: none;">
                <div class="stats-grid" id="statsGrid">
                    <!-- Stats will be populated here -->
                </div>
            </div>

            <!-- Terminal -->
            <div class="terminal-container">
                <div class="terminal-header">
                    <div class="terminal-title" id="terminalTitle">Select a container to view logs</div>
                    <div class="terminal-controls">
                        <button onclick="clearTerminal()">Clear</button>
                        <button onclick="toggleAutoScroll()" id="autoScrollBtn">Auto-scroll: On</button>
                        <button onclick="refreshLogs()">Refresh</button>
                        <button onclick="loadOlderLogs()" id="loadOlderBtn" disabled>Load Older</button>
                    </div>
                </div>
                <div class="terminal-content" id="terminalContent">
                    <div class="empty-terminal">
                        No container selected. Click on a container in the sidebar to view its error logs.
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentContainer = null;
        let autoScroll = true;
        let logsInterval = null;
        let statsInterval = null;
        let currentOffset = 0;
        let hasMoreLogs = true;
        let isLoadingMore = false;
        let allLoadedLogs = []; // Store all loaded logs to prevent losing history

        // Initialize the application
        async function initApp() {
            await loadContainers();
            
            // Set up intervals
            statsInterval = setInterval(loadStats, 60000); // 1 minute
            logsInterval = setInterval(loadNewLogsOnly, 60000); // 1 minute - only load new logs
            
            // Load initial data
            loadStats();
        }

        // Load containers list with proper status detection
        async function loadContainers() {
            try {
                const response = await fetch('/api/containers');
                const result = await response.json();
                const containers = result.containers || [];
                
                const containersList = document.getElementById('containersList');
                
                if (containers.length === 0) {
                    containersList.innerHTML = '<div class="empty-terminal">No containers running</div>';
                    return;
                }

                // Get fresh stats to ensure accurate container status
                const statsResponse = await fetch('/api/containers/stats');
                const statsResult = await statsResponse.json();
                const stats = statsResult.data || {};

                containersList.innerHTML = containers.map(name => {
                    const containerStats = stats[name] || {};
                    // Use the status from stats which should be more accurate
                    const status = containerStats.status || 'unknown';
                    const statusClass = `status-${status.toLowerCase()}`;
                    
                    return `
                        <div class="container-item" onclick="selectContainer('${name}')" id="container-${name}">
                            <div class="container-status ${statusClass}"></div>
                            <div class="container-name">${name}</div>
                        </div>
                    `;
                }).join('');

            } catch (error) {
                console.error('Error loading containers:', error);
                document.getElementById('containersList').innerHTML = '<div class="empty-terminal">Error loading containers</div>';
            }
        }

        // Load only new logs (for periodic updates)
        async function loadNewLogsOnly() {
            if (!currentContainer) return;
            
            try {
                // Load only the latest logs without offset
                const response = await fetch(`/api/errors/${currentContainer}?limit=50`);
                const result = await response.json();
                const newErrors = result.errors || [];
                
                if (newErrors.length > 0) {
                    // Merge new logs with existing logs, avoiding duplicates
                    mergeNewLogs(newErrors);
                }
                
            } catch (error) {
                console.error('Error loading new logs:', error);
            }
        }

        // Merge new logs with existing logs
        function mergeNewLogs(newErrors) {
            // Create a Set of existing log IDs to avoid duplicates
            const existingIds = new Set(allLoadedLogs.map(log => log.id));
            
            // Filter out logs that we already have
            const trulyNewLogs = newErrors.filter(log => !existingIds.has(log.id));
            
            if (trulyNewLogs.length > 0) {
                // Add new logs to the beginning of our collection (newest first in array)
                allLoadedLogs = [...trulyNewLogs, ...allLoadedLogs];
                
                // Re-display all logs
                displayAllLogs();
                
                // Update hasMoreLogs based on whether we have the complete history
                // This is a simple approach - you might want to make it smarter
                hasMoreLogs = allLoadedLogs.length >= 50; // If we have 50+ logs, assume there might be more
                updateLoadOlderButton();
            }
        }

        // Load older logs manually
        async function loadOlderLogs() {
            if (isLoadingMore || !hasMoreLogs || !currentContainer) return;
            
            try {
                isLoadingMore = true;
                updateLoadOlderButton();
                
                // Load older logs with offset - use limit 100 for consistency
                const response = await fetch(`/api/errors/${currentContainer}?limit=100&offset=${currentOffset + 100}`);
                const result = await response.json();
                const olderErrors = result.errors || [];
                const pagination = result.pagination || {};
                
                if (olderErrors.length > 0) {
                    currentOffset += 100;
                    
                    // Add older logs to the end of our collection
                    allLoadedLogs = [...allLoadedLogs, ...olderErrors];
                    
                    // Re-display all logs
                    displayAllLogs();
                }
                
                hasMoreLogs = pagination.has_next || false;
                updateLoadOlderButton();
                
            } catch (error) {
                console.error('Error loading older logs:', error);
            } finally {
                isLoadingMore = false;
                updateLoadOlderButton();
            }
        }

        // Update the Load Older button state
        function updateLoadOlderButton() {
            const loadOlderBtn = document.getElementById('loadOlderBtn');
            if (!currentContainer) {
                loadOlderBtn.disabled = true;
                loadOlderBtn.textContent = 'Load Older';
                return;
            }
            
            if (isLoadingMore) {
                loadOlderBtn.disabled = true;
                loadOlderBtn.textContent = 'Loading...';
            } else if (!hasMoreLogs) {
                loadOlderBtn.disabled = true;
                loadOlderBtn.textContent = 'No Older Logs';
            } else {
                loadOlderBtn.disabled = false;
                loadOlderBtn.textContent = 'Load Older';
            }
        }

        // Select container
        function selectContainer(containerName) {
            currentContainer = containerName;
            currentOffset = 0;
            hasMoreLogs = true;
            allLoadedLogs = []; // Reset loaded logs
            
            // Update UI
            document.querySelectorAll('.container-item').forEach(item => {
                item.classList.remove('active');
            });
            document.getElementById(`container-${containerName}`).classList.add('active');
            
            document.getElementById('terminalTitle').textContent = `Error Logs - ${containerName}`;
            document.getElementById('statsHeader').style.display = 'block';
            
            // Update button state
            updateLoadOlderButton();
            
            // Load initial data
            loadStats();
            loadInitialLogs();
        }

        // Load initial logs for a container
        async function loadInitialLogs() {
            if (!currentContainer) return;
            
            try {
                // Load initial batch of logs - use limit 100
                const response = await fetch(`/api/errors/${currentContainer}?limit=100`);
                const result = await response.json();
                const errors = result.errors || [];
                const pagination = result.pagination || {};
                
                allLoadedLogs = errors;
                currentOffset = 0;
                hasMoreLogs = pagination.has_next || false;
                
                displayAllLogs();
                updateLoadOlderButton();
            } catch (error) {
                console.error('Error loading initial logs:', error);
            }
        }

        // Display all currently loaded logs
        function displayAllLogs() {
            const terminalContent = document.getElementById('terminalContent');
            
            if (allLoadedLogs.length === 0) {
                terminalContent.innerHTML = '<div class="empty-terminal">No error logs found</div>';
                return;
            }
            
            // Group identical errors (ignoring timestamps in messages) and count occurrences
            const errorGroups = {};
            allLoadedLogs.forEach(error => {
                const cleanMessage = extractErrorMessage(error.error_message);
                if (!errorGroups[cleanMessage]) {
                    errorGroups[cleanMessage] = {
                        originalMessage: error.error_message, // Keep original for display
                        cleanMessage: cleanMessage,
                        occurrences: 0,
                        latestTimestamp: error.timestamp
                    };
                }
                errorGroups[cleanMessage].occurrences += error.occurrence_count || 1;
                
                // Keep the latest timestamp
                if (new Date(error.timestamp) > new Date(errorGroups[cleanMessage].latestTimestamp)) {
                    errorGroups[cleanMessage].latestTimestamp = error.timestamp;
                    errorGroups[cleanMessage].originalMessage = error.error_message; // Update to latest original message
                }
            });
            
            // Convert to array and sort by latest timestamp (oldest first, so newest appears at bottom)
            const groupedErrors = Object.values(errorGroups).sort((a, b) => 
                new Date(a.latestTimestamp) - new Date(b.latestTimestamp)
            );
            
            // Convert grouped errors to terminal lines
            const logLines = groupedErrors.map(group => {
                // Use browser's local time (like Iran time) instead of UTC
                const timestamp = new Date(group.latestTimestamp).toLocaleString();
                const logClass = getLogLevelClass(group.originalMessage);
                
                // Show occurrence count if more than 1
                const occurrenceText = group.occurrences > 1 ? ` [x${group.occurrences}]` : '';
                
                return `
                    <div class="log-line">
                        <span class="log-time">[${timestamp}]</span>
                        <span class="log-message ${logClass}">${escapeHtml(group.originalMessage)}${occurrenceText}</span>
                    </div>
                `;
            }).join('');
            
            terminalContent.innerHTML = logLines;
            
            // Auto-scroll to bottom to show latest errors
            if (autoScroll) {
                setTimeout(() => {
                    terminalContent.scrollTop = terminalContent.scrollHeight;
                }, 100);
            }
        }

        // Load stats for current container
        async function loadStats() {
            if (!currentContainer) return;
            
            try {
                const response = await fetch('/api/containers/stats');
                const result = await response.json();
                const stats = result.data || {};
                const containerStats = stats[currentContainer] || {};
                
                const statsGrid = document.getElementById('statsGrid');
                statsGrid.innerHTML = `
                    <div class="stat-item">
                        <div class="stat-label">Status</div>
                        <div class="stat-value">${containerStats.status || 'Unknown'}</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">CPU Usage</div>
                        <div class="stat-value">${(containerStats.cpu_percent || 0).toFixed(1)}%</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Memory Usage</div>
                        <div class="stat-value">${(containerStats.memory_percent || 0).toFixed(1)}%</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Memory</div>
                        <div class="stat-value">${formatBytes(containerStats.memory_bytes || 0)}</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Uptime</div>
                        <div class="stat-value">${formatUptime(containerStats.uptime_seconds || 0)}</div>
                    </div>
                `;
            } catch (error) {
                console.error('Error loading stats:', error);
            }
        }

        // Extract the actual error message without timestamps for grouping
        function extractErrorMessage(rawMessage) {
            // Remove common timestamp patterns from the beginning of messages
            return rawMessage
                .replace(/^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}(?:,\d+)?\s*/, '') // Remove "2025-11-21 13:35:08,011"
                .replace(/^\[\d{1,2}\/\d{1,2}\/\d{4}, \d{1,2}:\d{2}:\d{2} (?:AM|PM)\]\s*/, '') // Remove "[11/21/2025, 1:35:08 PM]"
                .replace(/^\d{2}:\d{2}:\d{2}\s*/, '') // Remove "13:35:08"
                .trim();
        }

        // Determine log level for coloring
        function getLogLevelClass(message) {
            const lowerMessage = message.toLowerCase();
            
            if (lowerMessage.includes('error') || lowerMessage.includes('exception') || lowerMessage.includes('failed')) {
                return 'log-error';
            } else if (lowerMessage.includes('warning') || lowerMessage.includes('warn')) {
                return 'log-warning';
            } else if (lowerMessage.includes('debug')) {
                return 'log-debug';
            } else {
                return 'log-info';
            }
        }

        // Terminal controls
        function clearTerminal() {
            allLoadedLogs = [];
            document.getElementById('terminalContent').innerHTML = '<div class="empty-terminal">Terminal cleared</div>';
            currentOffset = 0;
            hasMoreLogs = true;
            updateLoadOlderButton();
        }

        function toggleAutoScroll() {
            autoScroll = !autoScroll;
            document.getElementById('autoScrollBtn').textContent = `Auto-scroll: ${autoScroll ? 'On' : 'Off'}`;
        }

        function refreshLogs() {
            if (currentContainer) {
                loadInitialLogs();
            }
        }

        // Utility functions
        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function formatUptime(seconds) {
            if (seconds < 60) return `${Math.floor(seconds)}s`;
            if (seconds < 3600) return `${Math.floor(seconds / 60)}m`;
            if (seconds < 86400) return `${Math.floor(seconds / 3600)}h`;
            return `${Math.floor(seconds / 86400)}d`;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (logsInterval) clearInterval(logsInterval);
            if (statsInterval) clearInterval(statsInterval);
        });

        // Initialize app
        initApp();
    </script>
</body>
</html>
